<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Shield FX Testing Lab (Three.js r128)</title>
  <style>
    :root{
      --bg: rgba(10,12,18,0.72);
      --bg2: rgba(10,12,18,0.92);
      --txt: rgba(245,248,255,0.92);
      --muted: rgba(245,248,255,0.65);
      --line: rgba(255,255,255,0.10);
      --accent: #66d9ff;
      --warn: #ff6a6a;
      --ok: #63ffb0;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    html, body { height:100%; margin:0; background:#05060a; overflow:hidden; font-family:var(--sans); }
    canvas { display:block; }

    /* UI */
    #ui {
      position: fixed;
      top: 14px; left: 14px;
      width: min(420px, calc(100vw - 28px));
      max-height: calc(100vh - 28px);
      overflow: auto;
      background: linear-gradient(180deg, var(--bg2), var(--bg));
      color: var(--txt);
      border: 1px solid var(--line);
      border-radius: 14px;
      box-shadow: 0 18px 50px rgba(0,0,0,0.45);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    #ui header{
      padding: 12px 14px 10px 14px;
      border-bottom: 1px solid var(--line);
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      position: sticky; top: 0;
      background: linear-gradient(180deg, rgba(10,12,18,0.96), rgba(10,12,18,0.72));
      z-index: 2;
    }
    #title {
      display:flex; flex-direction:column; gap:2px;
    }
    #title .h1 {
      font-weight: 780;
      font-size: 13px;
      letter-spacing: 0.3px;
    }
    #title .sub {
      font-size: 11px;
      color: var(--muted);
    }
    #hudPills { display:flex; gap:8px; align-items:center; }
    .pill{
      font-family: var(--mono);
      font-size: 11px;
      padding: 6px 8px;
      border: 1px solid var(--line);
      border-radius: 999px;
      color: var(--txt);
      background: rgba(255,255,255,0.04);
      white-space: nowrap;
    }
    .pill b { font-weight: 800; }
    .pill.ok b { color: var(--ok); }
    .pill.warn b { color: var(--warn); }

    .section{
      padding: 12px 14px;
      border-bottom: 1px solid var(--line);
    }
    .section:last-child{ border-bottom: none; }
    .sectionTitle{
      font-size: 12px;
      font-weight: 800;
      letter-spacing: 0.25px;
      margin-bottom: 10px;
      display:flex; align-items:center; justify-content:space-between;
    }
    .sectionTitle .hint{
      font-size: 11px;
      color: var(--muted);
      font-weight: 650;
    }
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    label{
      display:flex;
      flex-direction:column;
      gap:6px;
      font-size: 11px;
      color: var(--muted);
    }
    select, input[type="range"], input[type="color"], button{
      font: inherit;
    }
    select{
      width:100%;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,0.04);
      color: var(--txt);
      outline:none;
    }
    input[type="color"]{
      width: 100%;
      height: 36px;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,0.04);
      padding: 0;
    }
    .row{
      display:flex; gap:10px; align-items:center;
    }
    .row > * { flex: 1; }
    .sliderRow{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:10px;
      align-items:center;
    }
    input[type="range"]{
      width:100%;
      accent-color: var(--accent);
    }
    .val{
      font-family: var(--mono);
      font-size: 11px;
      color: var(--txt);
      padding: 6px 8px;
      border: 1px solid var(--line);
      border-radius: 10px;
      background: rgba(255,255,255,0.04);
      min-width: 64px;
      text-align:right;
    }
    .btnRow{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    button{
      border: 1px solid var(--line);
      background: rgba(255,255,255,0.05);
      color: var(--txt);
      padding: 10px 10px;
      border-radius: 12px;
      cursor:pointer;
      transition: transform 0.05s ease, background 0.2s ease, border-color 0.2s ease;
      font-weight: 750;
      letter-spacing: 0.2px;
    }
    button:hover{ background: rgba(255,255,255,0.08); border-color: rgba(255,255,255,0.16); }
    button:active{ transform: translateY(1px); }
    button.primary{
      background: rgba(102,217,255,0.14);
      border-color: rgba(102,217,255,0.28);
    }
    button.danger{
      background: rgba(255,106,106,0.14);
      border-color: rgba(255,106,106,0.28);
    }
    .miniRow{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:10px;
    }
    .note{
      margin-top: 10px;
      color: var(--muted);
      font-size: 11px;
      line-height: 1.35;
    }
    #help {
      position: fixed;
      right: 14px; bottom: 14px;
      background: rgba(10,12,18,0.65);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 10px 12px;
      color: var(--txt);
      max-width: min(520px, calc(100vw - 28px));
      box-shadow: 0 18px 50px rgba(0,0,0,0.35);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      font-size: 11px;
      line-height: 1.45;
    }
    #help b { color: rgba(255,255,255,0.92); }
    #help code { font-family: var(--mono); font-size: 11px; color: rgba(255,255,255,0.9); }
    .kbd{
      font-family: var(--mono);
      font-size: 10px;
      padding: 2px 6px;
      border: 1px solid var(--line);
      border-bottom-color: rgba(255,255,255,0.18);
      border-radius: 8px;
      background: rgba(255,255,255,0.05);
      display:inline-block;
      transform: translateY(-1px);
      margin: 0 2px;
    }
  </style>
</head>

<body>
  <div id="ui">
    <header>
      <div id="title">
        <div class="h1">Shield FX Testing Lab</div>
        <div class="sub">Click the shield to aim • Built for fast FX iteration</div>
      </div>
      <div id="hudPills">
        <div class="pill" id="fpsPill">FPS <b id="fps">--</b></div>
        <div class="pill ok" id="energyPill">Shield <b id="energy">100</b>%</div>
        <div class="pill" id="overPill">Overload <b id="overload">NO</b></div>
      </div>
    </header>

    <div class="section">
      <div class="sectionTitle">
        <span>Setup</span>
        <span class="hint">Ship + Shield + Weapon</span>
      </div>
      <div class="grid2">
        <label>Ship
          <select id="shipSel">
            <option value="fighter">Light Fighter</option>
            <option value="interceptor">Interceptor</option>
            <option value="corvette">Corvette</option>
            <option value="freighter">Freighter / Tanker</option>
          </select>
        </label>
        <label>Shield Preset
          <select id="presetSel">
            <option value="0">Classic Energy Bubble</option>
            <option value="1">Hex / Cellular</option>
            <option value="2">Magnetic Field Lines</option>
            <option value="3">Hard‑Light Glass</option>
          </select>
        </label>
      </div>

      <div style="height:10px"></div>

      <div class="grid2">
        <label>Weapon
          <select id="weaponSel">
            <option value="laser">Laser Beam</option>
            <option value="plasma">Plasma Bolt</option>
            <option value="kinetic">Kinetic Slug</option>
            <option value="railgun">Railgun</option>
            <option value="emp">EMP Pulse</option>
            <option value="ion">Ion / Arc</option>
          </select>
        </label>
        <label>Slow Motion
          <select id="slowSel">
            <option value="1">1×</option>
            <option value="0.5">0.5×</option>
            <option value="0.25">0.25×</option>
          </select>
        </label>
      </div>

      <div class="note">
        <b>Shortcuts:</b> <span class="kbd">Space</span> Fire • <span class="kbd">R</span> Reset • <span class="kbd">1-6</span> Weapon • <span class="kbd">C</span> Impact Camera • <span class="kbd">O</span> Auto Sweep
      </div>
    </div>

    <div class="section">
      <div class="sectionTitle">
        <span>Shield Look</span>
        <span class="hint">Make it pop</span>
      </div>

      <div class="grid2">
        <label>Base Color
          <input id="baseColor" type="color" value="#2b8cff"/>
        </label>
        <label>Rim Color
          <input id="rimColor" type="color" value="#b6f7ff"/>
        </label>
      </div>

      <div style="height:10px"></div>

      <div class="sliderRow">
        <label style="grid-column:1 / span 2; gap:8px;">Opacity</label>
        <input id="opacity" type="range" min="0.05" max="0.9" step="0.01" value="0.28"/>
        <div class="val" id="opacityV">0.28</div>

        <label style="grid-column:1 / span 2; gap:8px;">Thickness (fake)</label>
        <input id="thickness" type="range" min="0.0" max="1.5" step="0.01" value="0.75"/>
        <div class="val" id="thicknessV">0.75</div>

        <label style="grid-column:1 / span 2; gap:8px;">Fresnel Power</label>
        <input id="fresnelPow" type="range" min="0.5" max="8.0" step="0.01" value="3.4"/>
        <div class="val" id="fresnelPowV">3.40</div>

        <label style="grid-column:1 / span 2; gap:8px;">Fresnel Intensity</label>
        <input id="fresnelInt" type="range" min="0.0" max="3.0" step="0.01" value="1.25"/>
        <div class="val" id="fresnelIntV">1.25</div>

        <label style="grid-column:1 / span 2; gap:8px;">Noise Scale</label>
        <input id="noiseScale" type="range" min="0.25" max="8.0" step="0.01" value="2.25"/>
        <div class="val" id="noiseScaleV">2.25</div>

        <label style="grid-column:1 / span 2; gap:8px;">Noise Speed</label>
        <input id="noiseSpeed" type="range" min="0.0" max="3.0" step="0.01" value="0.65"/>
        <div class="val" id="noiseSpeedV">0.65</div>

        <label style="grid-column:1 / span 2; gap:8px;">Noise Intensity</label>
        <input id="noiseInt" type="range" min="0.0" max="2.5" step="0.01" value="0.75"/>
        <div class="val" id="noiseIntV">0.75</div>

        <label style="grid-column:1 / span 2; gap:8px;">Hex Density (preset 2)</label>
        <input id="hexDensity" type="range" min="2.0" max="40.0" step="0.1" value="14.0"/>
        <div class="val" id="hexDensityV">14.0</div>

        <label style="grid-column:1 / span 2; gap:8px;">Shield Radius</label>
        <input id="radius" type="range" min="1.1" max="3.2" step="0.01" value="1.75"/>
        <div class="val" id="radiusV">1.75</div>
      </div>

      <div style="height:12px"></div>

      <div class="grid2">
        <label style="flex-direction:row; align-items:center; gap:10px; color:var(--txt);">
          <input id="impactCam" type="checkbox" checked />
          Impact Camera
        </label>
        <label style="flex-direction:row; align-items:center; gap:10px; color:var(--txt);">
          <input id="tightBubble" type="checkbox" />
          “Conformal” (tight bubble)
        </label>
      </div>
    </div>

    <div class="section">
      <div class="sectionTitle">
        <span>Impact Response</span>
        <span class="hint">Ripples + overload</span>
      </div>

      <div class="sliderRow">
        <label style="grid-column:1 / span 2; gap:8px;">Ripple Strength</label>
        <input id="rippleStr" type="range" min="0.0" max="2.5" step="0.01" value="1.15"/>
        <div class="val" id="rippleStrV">1.15</div>

        <label style="grid-column:1 / span 2; gap:8px;">Ripple Speed</label>
        <input id="rippleSpd" type="range" min="0.1" max="8.0" step="0.01" value="2.8"/>
        <div class="val" id="rippleSpdV">2.80</div>

        <label style="grid-column:1 / span 2; gap:8px;">Ripple Decay</label>
        <input id="rippleDec" type="range" min="0.2" max="6.0" step="0.01" value="2.15"/>
        <div class="val" id="rippleDecV">2.15</div>

        <label style="grid-column:1 / span 2; gap:8px;">Overload Threshold</label>
        <input id="overThr" type="range" min="0.2" max="3.0" step="0.01" value="1.25"/>
        <div class="val" id="overThrV">1.25</div>

        <label style="grid-column:1 / span 2; gap:8px;">Recovery Rate</label>
        <input id="recRate" type="range" min="0.02" max="1.2" step="0.01" value="0.28"/>
        <div class="val" id="recRateV">0.28</div>

        <label style="grid-column:1 / span 2; gap:8px;">Weapon Damage</label>
        <input id="dmg" type="range" min="0.2" max="5.0" step="0.01" value="1.0"/>
        <div class="val" id="dmgV">1.00</div>

        <label style="grid-column:1 / span 2; gap:8px;">Fire Rate</label>
        <input id="firerate" type="range" min="0.4" max="20.0" step="0.1" value="6.0"/>
        <div class="val" id="firerateV">6.0/s</div>
      </div>

      <div style="height:12px"></div>

      <div class="btnRow">
        <button class="primary" id="fireBtn">Fire (single)</button>
        <button id="burstBtn">Burst Test</button>
        <button id="sustainBtn">Sustained Test</button>
        <button class="danger" id="resetBtn">Reset Shield</button>
      </div>

      <div style="height:10px"></div>

      <div class="miniRow">
        <button id="precisionBtn">Precision</button>
        <button id="scatterBtn">Scatter</button>
        <button id="sweepBtn">Sweep</button>
      </div>

      <div style="height:10px"></div>

      <div class="btnRow">
        <button id="stressBtn">Stress Test</button>
        <button id="autoSweepBtn">Auto Impact Sweep</button>
      </div>

      <div class="note">
        <b>Aiming:</b> click on the shield to set an impact point. Tests use that point when possible.
      </div>
    </div>
  </div>

  <div id="help">
    <b>Shield readability tips:</b> push <code>Fresnel Intensity</code> + <code>Ripple Strength</code> up, keep <code>Opacity</code> ~0.18–0.35, and increase <code>Noise Scale</code> for “energy flow”.
    <br/><b>EMP:</b> looks best on presets 1–3. <b>Ion:</b> shows arcs crawling to emitter nodes.
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

  <script>
  (() => {
    // -----------------------------
    // Utilities
    // -----------------------------
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const lerp  = (a, b, t) => a + (b - a) * t;
    const smoothstep = (a,b,x)=>{ const t=clamp((x-a)/(b-a),0,1); return t*t*(3-2*t); };
    const hexToColor = (hex) => new THREE.Color(hex);
    const fmt = (v, n=2) => Number(v).toFixed(n);

    // -----------------------------
    // Renderer / Scene / Camera
    // -----------------------------
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.05;
    renderer.physicallyCorrectLights = true;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x05060a);
    scene.fog = new THREE.FogExp2(0x070912, 0.035);

    const camera = new THREE.PerspectiveCamera(55, window.innerWidth/window.innerHeight, 0.1, 120);
    camera.position.set(6.2, 3.6, 6.2);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.minDistance = 2.0;
    controls.maxDistance = 18.0;
    controls.target.set(0, 1.15, 0);

    // -----------------------------
    // Procedural cube env map (for fake refraction/reflection)
    // -----------------------------
    function makeFaceCanvas(drawFn) {
      const c = document.createElement('canvas');
      c.width = c.height = 256;
      const ctx = c.getContext('2d');
      drawFn(ctx, c.width, c.height);
      const tex = new THREE.CanvasTexture(c);
      tex.encoding = THREE.sRGBEncoding;
      tex.needsUpdate = true;
      return tex;
    }
    function makeEnvCube() {
      const faces = [];
      // soft sci-fi gradient with faint stars
      const draw = (ctx, w, h, top, bottom, stars=true) => {
        const g = ctx.createLinearGradient(0,0,0,h);
        g.addColorStop(0, top);
        g.addColorStop(1, bottom);
        ctx.fillStyle = g;
        ctx.fillRect(0,0,w,h);

        if (stars) {
          ctx.globalAlpha = 0.9;
          for (let i=0;i<120;i++){
            const x = Math.random()*w, y=Math.random()*h;
            const r = Math.random()<0.92 ? 1 : 2;
            ctx.fillStyle = `rgba(220,240,255,${Math.random()*0.6})`;
            ctx.fillRect(x,y,r,r);
          }
          ctx.globalAlpha = 1;
        }

        // subtle scan haze
        ctx.globalAlpha = 0.20;
        for (let i=0;i<10;i++){
          ctx.fillStyle = `rgba(120,170,255,${0.05 + Math.random()*0.05})`;
          ctx.fillRect(0, (i/10)*h + Math.random()*6, w, 1);
        }
        ctx.globalAlpha = 1;
      };

      const t1 = '#0b1430', b1 = '#020308';
      const t2 = '#081024', b2 = '#05060a';

      faces.push(makeFaceCanvas((ctx,w,h)=>draw(ctx,w,h,t1,b1,true))); // px
      faces.push(makeFaceCanvas((ctx,w,h)=>draw(ctx,w,h,t1,b1,true))); // nx
      faces.push(makeFaceCanvas((ctx,w,h)=>draw(ctx,w,h,t2,b2,false))); // py
      faces.push(makeFaceCanvas((ctx,w,h)=>draw(ctx,w,h,'#05060a','#020207',false))); // ny
      faces.push(makeFaceCanvas((ctx,w,h)=>draw(ctx,w,h,t1,b1,true))); // pz
      faces.push(makeFaceCanvas((ctx,w,h)=>draw(ctx,w,h,t1,b1,true))); // nz

      const cube = new THREE.CubeTexture(faces.map(t => t.image));
      cube.needsUpdate = true;
      cube.encoding = THREE.sRGBEncoding;
      return cube;
    }
    const envCube = makeEnvCube();
    scene.environment = envCube;

    // -----------------------------
    // Lab environment (hangar-ish)
    // -----------------------------
    const lab = new THREE.Group();
    scene.add(lab);

    // Floor grid (procedural canvas)
    function makeGridTexture() {
      const c = document.createElement('canvas');
      c.width = c.height = 512;
      const ctx = c.getContext('2d');
      ctx.fillStyle = '#070913';
      ctx.fillRect(0,0,c.width,c.height);

      const drawLine = (x1,y1,x2,y2,a,w) => {
        ctx.strokeStyle = `rgba(140,190,255,${a})`;
        ctx.lineWidth = w;
        ctx.beginPath();
        ctx.moveTo(x1,y1); ctx.lineTo(x2,y2);
        ctx.stroke();
      };

      for(let i=0;i<=32;i++){
        const t = i/32;
        const y = t*c.height;
        drawLine(0,y,c.width,y, i%8===0 ? 0.22 : 0.08, i%8===0 ? 2 : 1);
        const x = t*c.width;
        drawLine(x,0,x,c.height, i%8===0 ? 0.22 : 0.08, i%8===0 ? 2 : 1);
      }

      // subtle panel noise
      ctx.globalAlpha = 0.06;
      for(let i=0;i<4000;i++){
        const x = Math.random()*c.width, y=Math.random()*c.height;
        const a = Math.random();
        ctx.fillStyle = `rgba(255,255,255,${a})`;
        ctx.fillRect(x,y,1,1);
      }
      ctx.globalAlpha = 1;

      const tex = new THREE.CanvasTexture(c);
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      tex.repeat.set(3.5, 3.5);
      tex.encoding = THREE.sRGBEncoding;
      tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
      tex.needsUpdate = true;
      return tex;
    }
    const gridTex = makeGridTexture();

    const floorMat = new THREE.MeshStandardMaterial({
      color: 0x0a0d16,
      metalness: 0.65,
      roughness: 0.28,
      envMapIntensity: 0.6,
      map: gridTex
    });
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(40, 40), floorMat);
    floor.rotation.x = -Math.PI/2;
    floor.position.y = 0;
    floor.receiveShadow = false;
    lab.add(floor);

    // Back wall + side walls (dark)
    const wallMat = new THREE.MeshStandardMaterial({
      color: 0x070913,
      metalness: 0.3,
      roughness: 0.85,
      envMapIntensity: 0.25
    });
    const backWall = new THREE.Mesh(new THREE.PlaneGeometry(40, 16), wallMat);
    backWall.position.set(0, 8, -12);
    lab.add(backWall);

    const sideWallL = new THREE.Mesh(new THREE.PlaneGeometry(24, 16), wallMat);
    sideWallL.position.set(-12, 8, 0);
    sideWallL.rotation.y = Math.PI/2;
    lab.add(sideWallL);

    const sideWallR = new THREE.Mesh(new THREE.PlaneGeometry(24, 16), wallMat);
    sideWallR.position.set(12, 8, 0);
    sideWallR.rotation.y = -Math.PI/2;
    lab.add(sideWallR);

    // Accent rails
    const railMat = new THREE.MeshStandardMaterial({ color: 0x0b1230, metalness: 0.7, roughness: 0.35, envMapIntensity: 0.55 });
    for (let i=0;i<6;i++){
      const rail = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.22, 18), railMat);
      rail.position.set(-7 + i*2.8, 0.11, -3);
      lab.add(rail);
    }

    // Lights (cinematic key + rim + practical)
    const key = new THREE.DirectionalLight(0xbfe6ff, 3.2);
    key.position.set(6, 8, 3);
    scene.add(key);

    const fill = new THREE.DirectionalLight(0x88aaff, 1.2);
    fill.position.set(-6, 5, 7);
    scene.add(fill);

    const rim = new THREE.DirectionalLight(0x8cffd8, 2.0);
    rim.position.set(-5, 7, -8);
    scene.add(rim);

    const practicals = [];
    function addPractical(x,y,z, color, intensity, dist) {
      const p = new THREE.PointLight(color, intensity, dist, 2.2);
      p.position.set(x,y,z);
      scene.add(p);

      // visible bulb glow sprite
      const bulb = makeGlowSprite(new THREE.Color(color), 0.9);
      bulb.position.copy(p.position);
      bulb.scale.setScalar(0.7);
      lab.add(bulb);

      practicals.push({ light: p, base: intensity, phase: Math.random()*10 });
    }
    addPractical(-9.5, 5.5, -8, 0x66d9ff, 3.1, 22);
    addPractical( 9.5, 5.0, -6, 0x66ffcc, 2.8, 22);
    addPractical( 0.0, 6.5, -10,0x99bbff, 2.6, 24);

    // -----------------------------
    // Glow sprite helper (fake bloom)
    // -----------------------------
    function makeGlowSprite(color, intensity=1.0) {
      const c = document.createElement('canvas');
      c.width = c.height = 128;
      const ctx = c.getContext('2d');

      const g = ctx.createRadialGradient(64,64,0, 64,64,64);
      g.addColorStop(0.0, `rgba(255,255,255,${0.9*intensity})`);
      g.addColorStop(0.2, `rgba(${Math.floor(color.r*255)},${Math.floor(color.g*255)},${Math.floor(color.b*255)},${0.55*intensity})`);
      g.addColorStop(1.0, `rgba(0,0,0,0)`);

      ctx.fillStyle = g;
      ctx.fillRect(0,0,128,128);

      const tex = new THREE.CanvasTexture(c);
      tex.encoding = THREE.sRGBEncoding;
      const mat = new THREE.SpriteMaterial({
        map: tex,
        color: 0xffffff,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      const spr = new THREE.Sprite(mat);
      spr.renderOrder = 10;
      return spr;
    }

    // -----------------------------
    // Ship factory (procedural silhouettes)
    // -----------------------------
    const shipRoot = new THREE.Group();
    shipRoot.position.set(0, 1.05, 0);
    scene.add(shipRoot);

    function metal(color=0x101826, metalness=0.85, roughness=0.35) {
      return new THREE.MeshStandardMaterial({ color, metalness, roughness, envMapIntensity: 0.8 });
    }
    function paint(color=0x12192a, metalness=0.55, roughness=0.45) {
      return new THREE.MeshStandardMaterial({ color, metalness, roughness, envMapIntensity: 0.6 });
    }
    function emissive(color=0x66d9ff, intensity=2.0) {
      return new THREE.MeshStandardMaterial({ color: 0x0b0f18, metalness: 0.1, roughness: 0.5, emissive: new THREE.Color(color), emissiveIntensity: intensity });
    }

    function addEngineGlow(group, pos, color=0x66d9ff, scale=0.6) {
      const spr = makeGlowSprite(new THREE.Color(color), 1.0);
      spr.position.copy(pos);
      spr.scale.setScalar(scale);
      group.add(spr);
      const core = new THREE.Mesh(new THREE.SphereGeometry(0.06, 16, 16), emissive(color, 3.2));
      core.position.copy(pos);
      group.add(core);
    }

    function makeEmitterNodes(group, points, color=0x66ffcc) {
      const nodes = [];
      const mat = emissive(color, 2.6);
      const geo = new THREE.SphereGeometry(0.05, 14, 14);
      points.forEach(p => {
        const m = new THREE.Mesh(geo, mat);
        m.position.copy(p);
        group.add(m);
        const glow = makeGlowSprite(new THREE.Color(color), 0.65);
        glow.position.copy(p);
        glow.scale.setScalar(0.42);
        group.add(glow);
        nodes.push(m);
      });
      return nodes;
    }

    function buildFighter() {
      const g = new THREE.Group();

      const body = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.25, 2.0), paint(0x111a2b, 0.55, 0.48));
      body.position.set(0, 0, 0);
      g.add(body);

      const cockpit = new THREE.Mesh(new THREE.SphereGeometry(0.22, 20, 20), new THREE.MeshStandardMaterial({
        color: 0x0a1220, metalness: 0.1, roughness: 0.05, envMapIntensity: 1.0
      }));
      cockpit.scale.set(1.0, 0.75, 1.25);
      cockpit.position.set(0, 0.18, 0.35);
      g.add(cockpit);

      const wingMat = metal(0x0f1726, 0.85, 0.38);
      const wingL = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.08, 0.9), wingMat);
      wingL.position.set(-0.95, -0.06, 0.1);
      wingL.rotation.z = 0.18;
      g.add(wingL);
      const wingR = wingL.clone();
      wingR.position.x *= -1;
      wingR.rotation.z *= -1;
      g.add(wingR);

      const nose = new THREE.Mesh(new THREE.ConeGeometry(0.22, 0.85, 20), metal(0x0b1220,0.75,0.35));
      nose.rotation.x = Math.PI/2;
      nose.position.set(0, 0.02, 1.35);
      g.add(nose);

      const thruster = new THREE.Mesh(new THREE.CylinderGeometry(0.22, 0.28, 0.35, 20), metal(0x0b1220,0.85,0.28));
      thruster.rotation.x = Math.PI/2;
      thruster.position.set(0, 0, -1.08);
      g.add(thruster);

      addEngineGlow(g, new THREE.Vector3(0, 0.02, -1.28), 0x66d9ff, 0.75);

      const emitters = makeEmitterNodes(g, [
        new THREE.Vector3(-0.55, 0.02, 0.65),
        new THREE.Vector3( 0.55, 0.02, 0.65),
        new THREE.Vector3( 0.0, 0.10, -0.55),
      ], 0x66ffcc);

      return { group: g, emitters };
    }

    function buildInterceptor() {
      const g = new THREE.Group();

      const spine = new THREE.Mesh(new THREE.BoxGeometry(0.65, 0.22, 2.6), paint(0x0f1726,0.55,0.50));
      spine.position.set(0,0,0);
      g.add(spine);

      const longNose = new THREE.Mesh(new THREE.ConeGeometry(0.18, 1.15, 18), metal(0x0b1322,0.8,0.35));
      longNose.rotation.x = Math.PI/2;
      longNose.position.set(0,0.02,1.65);
      g.add(longNose);

      const finMat = metal(0x0d1424,0.85,0.33);
      const fin = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.65, 1.0), finMat);
      fin.position.set(0,0.35,-0.15);
      g.add(fin);

      const sidePodMat = metal(0x0c1323,0.85,0.32);
      const podL = new THREE.Mesh(new THREE.CylinderGeometry(0.13,0.16,1.55,16), sidePodMat);
      podL.rotation.x = Math.PI/2;
      podL.position.set(-0.55, -0.05, 0.15);
      g.add(podL);
      const podR = podL.clone();
      podR.position.x *= -1;
      g.add(podR);

      const cockpit = new THREE.Mesh(new THREE.SphereGeometry(0.18, 18, 18), new THREE.MeshStandardMaterial({
        color: 0x081021, metalness: 0.1, roughness: 0.06, envMapIntensity: 1.0
      }));
      cockpit.scale.set(1.1, 0.7, 1.5);
      cockpit.position.set(0,0.14,0.6);
      g.add(cockpit);

      const thrusterL = new THREE.Mesh(new THREE.CylinderGeometry(0.11, 0.15, 0.25, 16), sidePodMat);
      thrusterL.rotation.x = Math.PI/2;
      thrusterL.position.set(-0.55, -0.05, -1.0);
      g.add(thrusterL);
      const thrusterR = thrusterL.clone();
      thrusterR.position.x *= -1;
      g.add(thrusterR);

      addEngineGlow(g, new THREE.Vector3(-0.55, -0.04, -1.20), 0x66d9ff, 0.62);
      addEngineGlow(g, new THREE.Vector3( 0.55, -0.04, -1.20), 0x66d9ff, 0.62);

      const emitters = makeEmitterNodes(g, [
        new THREE.Vector3(-0.62, 0.02, 0.9),
        new THREE.Vector3( 0.62, 0.02, 0.9),
        new THREE.Vector3( 0.0, 0.22, -0.15),
        new THREE.Vector3( 0.0, 0.05, -0.85),
      ], 0x66ffcc);

      return { group: g, emitters };
    }

    function buildCorvette() {
      const g = new THREE.Group();

      const hull = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.4, 3.4), paint(0x101b2e,0.5,0.55));
      hull.position.set(0,0,0);
      g.add(hull);

      const bridge = new THREE.Mesh(new THREE.BoxGeometry(0.55, 0.28, 0.8), metal(0x0c1323,0.85,0.28));
      bridge.position.set(0,0.32,0.65);
      g.add(bridge);

      const module1 = new THREE.Mesh(new THREE.BoxGeometry(0.65, 0.3, 0.9), metal(0x0a1220,0.8,0.35));
      module1.position.set(-0.55, -0.05, -0.6);
      g.add(module1);
      const module2 = module1.clone();
      module2.position.x *= -1;
      g.add(module2);

      const gun = new THREE.Mesh(new THREE.CylinderGeometry(0.06,0.06,0.9, 12), metal(0x0e1628,0.8,0.3));
      gun.rotation.x = Math.PI/2;
      gun.position.set(0,0.12,1.35);
      g.add(gun);

      const stern = new THREE.Mesh(new THREE.CylinderGeometry(0.42,0.52,0.55, 22), metal(0x0b1220,0.85,0.26));
      stern.rotation.x = Math.PI/2;
      stern.position.set(0,0,-1.75);
      g.add(stern);

      addEngineGlow(g, new THREE.Vector3(-0.24, 0.02, -2.05), 0x66d9ff, 0.78);
      addEngineGlow(g, new THREE.Vector3( 0.24, 0.02, -2.05), 0x66d9ff, 0.78);

      const emitters = makeEmitterNodes(g, [
        new THREE.Vector3(-0.75, 0.05, 1.05),
        new THREE.Vector3( 0.75, 0.05, 1.05),
        new THREE.Vector3(-0.75, 0.00,-1.05),
        new THREE.Vector3( 0.75, 0.00,-1.05),
        new THREE.Vector3( 0.0,  0.26, 0.2),
      ], 0x66ffcc);

      return { group: g, emitters };
    }

    function buildFreighter() {
      const g = new THREE.Group();

      const core = new THREE.Mesh(new THREE.BoxGeometry(1.9, 0.6, 2.8), paint(0x0f1a2c,0.5,0.62));
      core.position.set(0,0,0);
      g.add(core);

      const podMat = metal(0x0b1220,0.85,0.32);
      const podA = new THREE.Mesh(new THREE.BoxGeometry(1.05, 0.45, 1.15), podMat);
      podA.position.set(-1.25, -0.12, 0.35);
      podA.rotation.y = 0.06;
      g.add(podA);

      const podB = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.4, 1.35), podMat);
      podB.position.set(1.1, -0.15, -0.55);
      podB.rotation.y = -0.08;
      g.add(podB);

      const spine = new THREE.Mesh(new THREE.CylinderGeometry(0.18,0.18,3.4, 16), metal(0x0c1426,0.8,0.35));
      spine.rotation.x = Math.PI/2;
      spine.position.set(0,0.18,-0.1);
      g.add(spine);

      const aft = new THREE.Mesh(new THREE.CylinderGeometry(0.55,0.7,0.65, 24), metal(0x0b1220,0.85,0.25));
      aft.rotation.x = Math.PI/2;
      aft.position.set(0,0,-1.75);
      g.add(aft);

      addEngineGlow(g, new THREE.Vector3(0, 0.02, -2.10), 0x66d9ff, 0.95);

      const emitters = makeEmitterNodes(g, [
        new THREE.Vector3(-1.05, 0.10, 0.95),
        new THREE.Vector3( 1.05, 0.08, 0.65),
        new THREE.Vector3(-0.35, 0.22,-0.35),
        new THREE.Vector3( 0.35, 0.22,-0.35),
        new THREE.Vector3( 0.0,  0.00,-1.25),
      ], 0x66ffcc);

      return { group: g, emitters };
    }

    let currentShip = null;
    let shipEmitters = [];
    function setShip(kind) {
      if (currentShip) shipRoot.remove(currentShip);
      shipEmitters = [];
      let built;
      if (kind === 'fighter') built = buildFighter();
      if (kind === 'interceptor') built = buildInterceptor();
      if (kind === 'corvette') built = buildCorvette();
      if (kind === 'freighter') built = buildFreighter();

      currentShip = built.group;
      shipEmitters = built.emitters;

      // subtle tilt for style
      currentShip.rotation.y = -0.35;
      shipRoot.add(currentShip);
    }
    setShip('fighter');

    // -----------------------------
    // Turret / source emitter for shots
    // -----------------------------
    const turret = new THREE.Group();
    turret.position.set(-7.6, 2.25, 4.9);
    scene.add(turret);

    const turretBase = new THREE.Mesh(new THREE.CylinderGeometry(0.55,0.65,0.35, 24), metal(0x0b1322,0.8,0.35));
    turretBase.position.y = -0.15;
    turret.add(turretBase);

    const turretNeck = new THREE.Mesh(new THREE.CylinderGeometry(0.16,0.22,0.9, 16), metal(0x0b1322,0.8,0.35));
    turretNeck.position.y = 0.35;
    turret.add(turretNeck);

    const turretHead = new THREE.Mesh(new THREE.BoxGeometry(0.55,0.35,0.85), metal(0x0d1526,0.85,0.32));
    turretHead.position.y = 0.8;
    turret.add(turretHead);

    const muzzle = new THREE.Mesh(new THREE.CylinderGeometry(0.07,0.10,0.55, 14), metal(0x0f1a2c,0.8,0.3));
    muzzle.rotation.x = Math.PI/2;
    muzzle.position.set(0,0.8,0.65);
    turret.add(muzzle);

    const muzzleGlow = makeGlowSprite(new THREE.Color(0x66d9ff), 0.8);
    muzzleGlow.position.set(0,0.8,0.95);
    muzzleGlow.scale.setScalar(0.6);
    turret.add(muzzleGlow);

    // -----------------------------
    // Shield shader
    // -----------------------------
    const MAX_IMPACTS = 8;

    const shieldVert = `
      varying vec3 vWorldPos;
      varying vec3 vNormalW;
      varying vec3 vViewDirW;
      varying vec2 vUv;

      void main() {
        vUv = uv;
        vec4 wp = modelMatrix * vec4(position, 1.0);
        vWorldPos = wp.xyz;
        vNormalW = normalize(mat3(modelMatrix) * normal);
        vViewDirW = normalize(cameraPosition - vWorldPos);
        gl_Position = projectionMatrix * viewMatrix * wp;
      }
    `;

    const shieldFrag = `
      precision highp float;

      #define MAX_IMPACTS ${MAX_IMPACTS}

      varying vec3 vWorldPos;
      varying vec3 vNormalW;
      varying vec3 vViewDirW;
      varying vec2 vUv;

      uniform float uTime;
      uniform int uPreset;
      uniform vec3 uBaseColor;
      uniform vec3 uRimColor;
      uniform float uOpacity;
      uniform float uThickness;

      uniform float uFresnelPower;
      uniform float uFresnelIntensity;

      uniform float uNoiseScale;
      uniform float uNoiseSpeed;
      uniform float uNoiseIntensity;

      uniform float uHexDensity;

      uniform float uRippleStrength;
      uniform float uRippleSpeed;
      uniform float uRippleDecay;

      uniform float uOverload;
      uniform float uEnergy;
      uniform float uEmp;      // global emp flicker amount 0..1

      uniform samplerCube uEnv;

      uniform int uImpactCount;
      uniform vec3 uImpactPos[MAX_IMPACTS];   // local normalized (direction on sphere)
      uniform float uImpactTime[MAX_IMPACTS];
      uniform float uImpactStrength[MAX_IMPACTS];
      uniform float uImpactType[MAX_IMPACTS]; // 0..5

      // hash + noise
      float hash13(vec3 p){
        p = fract(p * 0.1031);
        p += dot(p, p.yzx + 33.33);
        return fract((p.x + p.y) * p.z);
      }

      float noise3(vec3 p){
        vec3 i = floor(p);
        vec3 f = fract(p);
        // smoothstep
        f = f*f*(3.0-2.0*f);

        float n000 = hash13(i + vec3(0,0,0));
        float n100 = hash13(i + vec3(1,0,0));
        float n010 = hash13(i + vec3(0,1,0));
        float n110 = hash13(i + vec3(1,1,0));
        float n001 = hash13(i + vec3(0,0,1));
        float n101 = hash13(i + vec3(1,0,1));
        float n011 = hash13(i + vec3(0,1,1));
        float n111 = hash13(i + vec3(1,1,1));

        float nx00 = mix(n000, n100, f.x);
        float nx10 = mix(n010, n110, f.x);
        float nx01 = mix(n001, n101, f.x);
        float nx11 = mix(n011, n111, f.x);
        float nxy0 = mix(nx00, nx10, f.y);
        float nxy1 = mix(nx01, nx11, f.y);
        return mix(nxy0, nxy1, f.z);
      }

      float fbm(vec3 p){
        float v = 0.0;
        float a = 0.55;
        for(int i=0;i<5;i++){
          v += a * noise3(p);
          p *= 2.02;
          a *= 0.55;
        }
        return v;
      }

      // Hex pattern in UV space
      float hexDist(vec2 p){
        // from iq
        p = abs(p);
        return max(dot(p, normalize(vec2(1.0, 1.7320508))), p.x);
      }
      float hexGrid(vec2 uv, float scale){
        vec2 p = uv * scale;
        // offset every other row
        p.y *= 1.1547005; // 2/sqrt(3)
        vec2 row = floor(vec2(p.x + 0.5*floor(p.y), p.y));
        vec2 f = p - vec2(row.x - 0.5*floor(row.y), row.y);
        f -= 0.5;
        float d = hexDist(f);
        // cell fill + edge
        float edge = smoothstep(0.48, 0.44, d);
        float fill = smoothstep(0.52, 0.40, d);
        return mix(fill, edge, 0.6);
      }

      vec3 envSample(vec3 dir){
        return textureCube(uEnv, dir).rgb;
      }

      // ring + hotspot from one impact
      void impactField(vec3 n, int idx, float tNow, out float ring, out float hot, out float crack){
        float t0 = uImpactTime[idx];
        float dt = max(0.0, tNow - t0);
        vec3 ip = normalize(uImpactPos[idx]);

        // angular distance on unit sphere
        float ang = acos(clamp(dot(n, ip), -1.0, 1.0));
        float d = ang; // radians ~ arc length on unit sphere

        float strength = uImpactStrength[idx];

        // ripple ring
        float r = dt * uRippleSpeed;
        float w = mix(0.015, 0.06, clamp(strength, 0.0, 1.0));
        float ringCore = exp(-pow((d - r) / w, 2.0));
        float decay = exp(-dt * uRippleDecay);

        ring = ringCore * decay * strength;

        // hotspot (heat / overcharge)
        float h = exp(-d * mix(10.0, 25.0, 1.0 - strength));
        hot = h * exp(-dt * mix(1.2, 2.8, strength)) * strength;

        // crackle / sparks (kinetic & rail-like)
        float type = uImpactType[idx];
        float crackMask = smoothstep(0.25, 1.0, type) * smoothstep(0.0, 0.5, dt) * exp(-dt*4.0);
        float n1 = fbm(n*40.0 + vec3(0.0, 0.0, tNow*3.0));
        float n2 = fbm(n*65.0 + vec3(0.0, tNow*5.0, 0.0));
        crack = crackMask * hot * smoothstep(0.78, 0.95, n1) * smoothstep(0.65, 0.9, n2);
      }

      void main() {
        vec3 N = normalize(vNormalW);
        vec3 V = normalize(vViewDirW);

        float ndv = clamp(dot(N, V), 0.0, 1.0);
        float fres = pow(1.0 - ndv, uFresnelPower) * uFresnelIntensity;

        // base flow noise
        vec3 flowP = N * uNoiseScale + vec3(uTime*uNoiseSpeed, -uTime*uNoiseSpeed*0.7, uTime*uNoiseSpeed*0.4);
        float nFlow = fbm(flowP) * 2.0 - 1.0;
        float flow = 0.5 + 0.5 * nFlow;
        float flowBoost = uNoiseIntensity * (0.25 + 0.75*flow);

        // global overload instability
        float overloadPulse = 0.0;
        if (uOverload > 0.0) {
          overloadPulse = (0.6 + 0.4*sin(uTime*8.0)) * uOverload;
        }

        // impacts accumulation
        float ringSum = 0.0;
        float hotSum  = 0.0;
        float crackSum= 0.0;
        float ionStreak = 0.0;
        float laserShimmer = 0.0;
        float empScan = 0.0;

        for(int i=0;i<MAX_IMPACTS;i++){
          if (i >= uImpactCount) break;

          float ring, hot, crack;
          impactField(N, i, uTime, ring, hot, crack);

          ringSum += ring;
          hotSum  += hot;
          crackSum+= crack;

          float type = uImpactType[i];
          // 0 laser: shimmer
          laserShimmer += (1.0 - smoothstep(0.0, 0.25, type)) * hot * (0.5 + 0.5*sin(uTime*28.0 + dot(N, vec3(9.0,7.0,11.0))));
          // 5 ion: streaks crawling
          float ionMask = smoothstep(4.5, 5.1, type);
          if (ionMask > 0.0) {
            float a = atan(N.z, N.x);
            float l = N.y;
            float lines = sin(a*18.0 + uTime*6.0 + fbm(N*12.0 + uTime)*2.0) * sin(l*22.0 - uTime*5.0);
            ionStreak += ionMask * hot * smoothstep(0.55, 0.95, abs(lines));
          }
          // 4 emp: global scan shimmer
          float empMask = smoothstep(3.7, 4.4, type);
          empScan += empMask * (0.5 + 0.5*sin((vUv.y*90.0) + uTime*18.0));
        }

        ringSum = clamp(ringSum * uRippleStrength, 0.0, 2.0);
        hotSum  = clamp(hotSum  * 1.4, 0.0, 2.0);
        crackSum= clamp(crackSum * 1.8, 0.0, 2.0);

        // preset features
        float hex = 0.0;
        float fieldLines = 0.0;
        float hardEdge = 0.0;

        if (uPreset == 1) { // hex / cellular
          float h = hexGrid(vUv, uHexDensity);
          // light up near impact
          hex = h * (0.35 + 1.25*hotSum + 0.85*ringSum);
        } else if (uPreset == 2) { // magnetic field lines
          // spherical coords-ish
          float a = atan(N.z, N.x);
          float l = N.y;
          float w = fbm(N*8.0 + vec3(0.0, uTime*0.6, 0.0))*0.35;
          float linesA = sin(a*14.0 + uTime*1.2 + w);
          float linesL = sin(l*18.0 - uTime*1.1 + w);
          fieldLines = smoothstep(0.65, 0.98, abs(linesA*linesL)) * (0.35 + 1.35*ringSum + 0.6*hotSum);
        } else if (uPreset == 3) { // hard-light glass
          hardEdge = smoothstep(0.25, 0.85, fres) * 1.3;
        }

        // fake refraction/reflection mix
        vec3 R = reflect(-V, N);
        vec3 refr = refract(-V, N, 0.92);
        vec3 envR = envSample(R);
        vec3 envT = envSample(refr);

        float energy = clamp(uEnergy, 0.0, 1.0);
        // lower energy -> noisier + more visible field
        float low = 1.0 - energy;

        // base color shifts under overload / emp
        vec3 base = uBaseColor;
        vec3 rimC = uRimColor;

        // EMP flicker overlay
        float emp = clamp(uEmp + 0.35*empScan, 0.0, 1.0);
        float empFlick = emp * (0.45 + 0.55*sin(uTime*42.0 + dot(N, vec3(3.0,5.0,7.0))));
        base = mix(base, vec3(0.75, 0.9, 1.0), 0.25*emp);
        rimC = mix(rimC, vec3(0.95, 0.98, 1.0), 0.35*emp);

        // Overload shifts toward hotter rim
        base = mix(base, vec3(0.75, 0.22, 0.25), 0.20*overloadPulse);
        rimC = mix(rimC, vec3(1.0, 0.35, 0.35), 0.25*overloadPulse);

        // thickness cue
        float thickness = uThickness;
        float depth = (0.35 + 0.65*fres) * thickness;

        // Compose intensity layers (readability first)
        float impactGlow = 0.0;
        impactGlow += 1.1*hotSum + 1.2*ringSum + 1.3*crackSum + 0.85*ionStreak + 0.55*laserShimmer;

        float field = 0.0;
        field += flowBoost * (0.30 + 0.70*fres);
        field += hex * 0.55;
        field += fieldLines * 0.70;
        field += hardEdge * 0.45;

        // Overload instability
        float instab = 0.0;
        instab += overloadPulse * (0.35 + 0.65*fbm(N*22.0 + uTime*2.0));
        instab += low * (0.10 + 0.25*fbm(N*12.0 + uTime*0.6));

        // final opacity
        float alpha = uOpacity;
        alpha += 0.12*fres + 0.18*impactGlow;
        alpha += 0.06*field;
        alpha += 0.10*instab;
        alpha += 0.12*empFlick;
        alpha = clamp(alpha, 0.02, 0.96);

        // final color
        vec3 col = base;

        // Refraction tint: let background show through but with energy tint
        vec3 refrTint = mix(envT, envR, 0.35);
        col = mix(refrTint, col, 0.55);

        // Add field energy + rim
        col += base * (0.16 + 0.55*field);
        col += rimC * fres * (0.65 + 0.8*impactGlow);

        // Impact highlight (local bloom-ish)
        col += rimC * impactGlow * 1.35;

        // EMP scanlines are a bit desaturated/glassy
        col = mix(col, col*vec3(0.88,0.93,1.0), 0.30*emp);

        // Hard-light preset: glassier + sharper highlights
        if (uPreset == 3) {
          col = mix(col, refrTint, 0.35);
          col += vec3(1.0) * (0.18 + 0.25*hardEdge + 0.35*crackSum);
        }

        // Clamp to keep it from blowing out too hard
        col = clamp(col, vec3(0.0), vec3(6.0));

        gl_FragColor = vec4(col, alpha);
      }
    `;

    const shieldUniforms = {
      uTime: { value: 0 },
      uPreset: { value: 0 },
      uBaseColor: { value: new THREE.Color(0x2b8cff) },
      uRimColor: { value: new THREE.Color(0xb6f7ff) },
      uOpacity: { value: 0.28 },
      uThickness: { value: 0.75 },
      uFresnelPower: { value: 3.4 },
      uFresnelIntensity: { value: 1.25 },
      uNoiseScale: { value: 2.25 },
      uNoiseSpeed: { value: 0.65 },
      uNoiseIntensity: { value: 0.75 },
      uHexDensity: { value: 14.0 },
      uRippleStrength: { value: 1.15 },
      uRippleSpeed: { value: 2.8 },
      uRippleDecay: { value: 2.15 },
      uOverload: { value: 0.0 },
      uEnergy: { value: 1.0 },
      uEmp: { value: 0.0 },
      uEnv: { value: envCube },
      uImpactCount: { value: 0 },
      uImpactPos: { value: Array.from({length: MAX_IMPACTS}, ()=>new THREE.Vector3(0,1,0)) },
      uImpactTime: { value: new Float32Array(MAX_IMPACTS) },
      uImpactStrength: { value: new Float32Array(MAX_IMPACTS) },
      uImpactType: { value: new Float32Array(MAX_IMPACTS) },
    };

    const shieldMat = new THREE.ShaderMaterial({
      vertexShader: shieldVert,
      fragmentShader: shieldFrag,
      uniforms: shieldUniforms,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      side: THREE.FrontSide
    });

    const shieldGeo = new THREE.SphereGeometry(1.75, 96, 64);
    const shield = new THREE.Mesh(shieldGeo, shieldMat);
    shield.position.copy(shipRoot.position);
    shield.renderOrder = 2;
    scene.add(shield);

    // subtle outer rim glow layer (cheap bloom + thickness)
    const glowMat = new THREE.MeshBasicMaterial({
      color: 0x66d9ff,
      transparent: true,
      opacity: 0.05,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
      side: THREE.BackSide
    });
    const shieldGlow = new THREE.Mesh(new THREE.SphereGeometry(1.78, 48, 32), glowMat);
    shieldGlow.position.copy(shield.position);
    shieldGlow.renderOrder = 1;
    scene.add(shieldGlow);

    // Aim indicator
    const aim = new THREE.Group();
    scene.add(aim);
    const aimDot = new THREE.Mesh(new THREE.SphereGeometry(0.045, 18, 18), emissive(0xb6f7ff, 2.8));
    const aimGlow = makeGlowSprite(new THREE.Color(0xb6f7ff), 0.9);
    aimGlow.scale.setScalar(0.55);
    aim.add(aimDot);
    aim.add(aimGlow);
    aim.visible = false;

    // -----------------------------
    // Impacts management
    // -----------------------------
    const impacts = [];
    function addImpact(worldPoint, type, strength=1.0) {
      const local = shield.worldToLocal(worldPoint.clone());
      const dir = local.clone().normalize(); // direction on sphere

      const t = clock.getElapsedTime();
      const s = clamp(strength, 0.0, 2.0);

      impacts.push({ dir, t, s, type });
      while (impacts.length > MAX_IMPACTS) impacts.shift();

      shieldUniforms.uImpactCount.value = impacts.length;
      for (let i=0;i<MAX_IMPACTS;i++){
        if (i < impacts.length) {
          shieldUniforms.uImpactPos.value[i].copy(impacts[i].dir);
          shieldUniforms.uImpactTime.value[i] = impacts[i].t;
          shieldUniforms.uImpactStrength.value[i] = impacts[i].s;
          shieldUniforms.uImpactType.value[i] = impacts[i].type;
        } else {
          shieldUniforms.uImpactPos.value[i].set(0,1,0);
          shieldUniforms.uImpactTime.value[i] = -9999;
          shieldUniforms.uImpactStrength.value[i] = 0;
          shieldUniforms.uImpactType.value[i] = 0;
        }
      }

      // flash practical lights briefly
      flashKick = 1.0;

      // impact camera nudge
      if (state.impactCam) triggerImpactCam(worldPoint);
    }

    // -----------------------------
    // Weapon FX: visuals + energy drain behavior
    // -----------------------------
    const fx = new THREE.Group();
    scene.add(fx);

    const activeFX = [];
    function spawnFX(obj, life=0.5, updateFn=null) {
      fx.add(obj);
      activeFX.push({ obj, t0: clock.getElapsedTime(), life, updateFn });
      return obj;
    }

    function killAllFX() {
      while (activeFX.length) {
        const f = activeFX.pop();
        fx.remove(f.obj);
      }
    }

    function makeBeam(start, end, color, thickness=0.03, opacity=0.9) {
      const dir = end.clone().sub(start);
      const len = dir.length();
      const mid = start.clone().addScaledVector(dir, 0.5);

      const geo = new THREE.CylinderGeometry(thickness, thickness, len, 10, 1, true);
      const mat = new THREE.MeshBasicMaterial({
        color,
        transparent: true,
        opacity,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      const m = new THREE.Mesh(geo, mat);
      m.position.copy(mid);

      // orient cylinder along dir (y axis)
      m.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), dir.normalize());
      m.renderOrder = 20;
      return m;
    }

    function makeProjectile(color, radius=0.07) {
      const core = new THREE.Mesh(new THREE.SphereGeometry(radius, 18, 18), new THREE.MeshBasicMaterial({
        color, transparent:true, opacity: 0.9, blending: THREE.AdditiveBlending, depthWrite:false
      }));
      const glow = makeGlowSprite(new THREE.Color(color), 1.0);
      glow.scale.setScalar(radius*10);
      const g = new THREE.Group();
      g.add(core); g.add(glow);
      g.renderOrder = 20;
      return g;
    }

    function makeSparkBurst(pos, color=0xb6f7ff, count=40, spread=0.22, life=0.35) {
      const geo = new THREE.BufferGeometry();
      const positions = new Float32Array(count * 3);
      const velocities = new Float32Array(count * 3);
      for (let i=0;i<count;i++){
        const v = new THREE.Vector3(
          (Math.random()*2-1),
          (Math.random()*2-1),
          (Math.random()*2-1)
        ).normalize().multiplyScalar(spread * (0.25 + Math.random()));
        positions[i*3+0] = pos.x;
        positions[i*3+1] = pos.y;
        positions[i*3+2] = pos.z;
        velocities[i*3+0] = v.x;
        velocities[i*3+1] = v.y;
        velocities[i*3+2] = v.z;
      }
      geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geo.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
      const mat = new THREE.PointsMaterial({
        color,
        size: 0.03,
        transparent: true,
        opacity: 0.9,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      const pts = new THREE.Points(geo, mat);
      pts.renderOrder = 25;

      spawnFX(pts, life, (o, age, dt) => {
        const p = o.geometry.attributes.position.array;
        const v = o.geometry.attributes.velocity.array;
        const fade = 1.0 - (age / life);
        o.material.opacity = 0.9 * fade;
        for (let i=0;i<count;i++){
          p[i*3+0] += v[i*3+0] * dt * 3.5;
          p[i*3+1] += v[i*3+1] * dt * 3.5;
          p[i*3+2] += v[i*3+2] * dt * 3.5;
          // drag
          v[i*3+0] *= 0.92;
          v[i*3+1] *= 0.92;
          v[i*3+2] *= 0.92;
        }
        o.geometry.attributes.position.needsUpdate = true;
      });
    }

    // EMP visual: expanding shell
    function spawnEMP(origin, maxR, color=0xb6f7ff) {
      const geo = new THREE.SphereGeometry(0.2, 28, 18);
      const mat = new THREE.MeshBasicMaterial({
        color,
        transparent: true,
        opacity: 0.35,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        side: THREE.DoubleSide
      });
      const m = new THREE.Mesh(geo, mat);
      m.position.copy(origin);
      m.renderOrder = 19;

      spawnFX(m, 0.9, (o, age) => {
        const t = age / 0.9;
        const r = lerp(0.2, maxR, smoothstep(0.0, 1.0, t));
        o.scale.setScalar(r / 0.2);
        o.material.opacity = 0.35 * (1.0 - t);
      });
    }

    // Ion arcs: line segments that crawl from impact towards nearest emitters
    function spawnIonArcs(impactPoint, color=0x66ffcc) {
      if (!shipEmitters.length) return;

      // choose a few nearest emitters
      const candidates = shipEmitters
        .map(e => ({ e, d: e.getWorldPosition(new THREE.Vector3()).distanceTo(impactPoint) }))
        .sort((a,b)=>a.d-b.d)
        .slice(0, 3);

      candidates.forEach((c, idx) => {
        const a = impactPoint.clone();
        const b = c.e.getWorldPosition(new THREE.Vector3()).clone();

        // create a jittery polyline
        const segs = 14;
        const pts = [];
        for (let i=0;i<=segs;i++){
          const t = i / segs;
          const p = a.clone().lerp(b, t);
          // lift onto shield surface (approx)
          const fromCenter = p.clone().sub(shield.position).normalize();
          p.copy(shield.position).addScaledVector(fromCenter, state.radius * 1.001);

          // jitter sideways
          const jitter = new THREE.Vector3(
            (Math.random()*2-1),
            (Math.random()*2-1),
            (Math.random()*2-1)
          ).normalize().multiplyScalar(0.07*(1.0 - Math.abs(0.5 - t)*1.7));
          p.add(jitter);
          pts.push(p);
        }

        const geo = new THREE.BufferGeometry().setFromPoints(pts);
        const mat = new THREE.LineBasicMaterial({
          color,
          transparent:true,
          opacity: 0.95,
          blending: THREE.AdditiveBlending,
          depthWrite:false
        });
        const line = new THREE.Line(geo, mat);
        line.renderOrder = 30;

        spawnFX(line, 0.25 + idx*0.05, (o, age) => {
          // animate jitter over time
          const p = o.geometry.attributes.position.array;
          const fade = 1.0 - age / (0.25 + idx*0.05);
          o.material.opacity = 0.95 * fade;

          for (let i=0;i<=segs;i++){
            const t = i / segs;
            const wob = Math.sin(age*30.0 + i*2.2) * (0.012 + 0.025*(1.0 - Math.abs(0.5 - t)*1.6));
            p[i*3+0] += wob * (Math.random()*2-1) * 0.2;
            p[i*3+1] += wob * (Math.random()*2-1) * 0.2;
            p[i*3+2] += wob * (Math.random()*2-1) * 0.2;
          }
          o.geometry.attributes.position.needsUpdate = true;
        });
      });
    }

    // Weapon "profiles": distinct shield reactions via impact strength/type + visuals
    const WEAPON = {
      laser:   { type: 0, travel: 0.0,  ringMul: 0.55, hotMul: 0.75, spark: 0.18, beam: true  },
      plasma:  { type: 1, travel: 0.55, ringMul: 0.90, hotMul: 1.35, spark: 0.25, beam: false },
      kinetic: { type: 2, travel: 0.22, ringMul: 1.30, hotMul: 0.65, spark: 0.55, beam: false },
      railgun: { type: 3, travel: 0.0,  ringMul: 1.55, hotMul: 0.85, spark: 0.65, beam: true  },
      emp:     { type: 4, travel: 0.0,  ringMul: 0.45, hotMul: 0.25, spark: 0.10, beam: false },
      ion:     { type: 5, travel: 0.0,  ringMul: 0.80, hotMul: 1.00, spark: 0.35, beam: true  },
    };

    // -----------------------------
    // Aim / Raycast
    // -----------------------------
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2(0,0);
    let lastAimPoint = null;

    function updateTurretAim(targetWorld) {
      // aim turret head at target
      const headWorld = turret.localToWorld(new THREE.Vector3(0, 0.8, 0));
      const dir = targetWorld.clone().sub(headWorld).normalize();
      const yaw = Math.atan2(dir.x, dir.z);
      const pitch = Math.asin(clamp(dir.y, -0.85, 0.85));
      turret.rotation.y = yaw;
      turretHead.rotation.x = -pitch * 0.55;
      muzzle.rotation.x = Math.PI/2 - pitch*0.55;
    }

    function setAimAt(pointWorld) {
      lastAimPoint = pointWorld.clone();
      aim.visible = true;
      aim.position.copy(pointWorld);
      updateTurretAim(pointWorld);
    }

    function raycastShield(clientX, clientY) {
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -(((clientY - rect.top) / rect.height) * 2 - 1);
      raycaster.setFromCamera(mouse, camera);

      const hit = raycaster.intersectObject(shield, false);
      if (hit.length) {
        return hit[0].point.clone();
      }
      return null;
    }

    renderer.domElement.addEventListener('pointerdown', (e) => {
      const p = raycastShield(e.clientX, e.clientY);
      if (p) setAimAt(p);
    });

    // -----------------------------
    // Shield energy + overload model
    // -----------------------------
    const state = {
      ship: 'fighter',
      preset: 0,
      weapon: 'laser',
      slow: 1.0,
      impactCam: true,
      tightBubble: false,

      // shield params
      baseColor: '#2b8cff',
      rimColor: '#b6f7ff',
      opacity: 0.28,
      thickness: 0.75,
      fresPow: 3.4,
      fresInt: 1.25,
      noiseScale: 2.25,
      noiseSpeed: 0.65,
      noiseInt: 0.75,
      hexDensity: 14.0,
      radius: 1.75,

      rippleStr: 1.15,
      rippleSpd: 2.8,
      rippleDec: 2.15,

      overThr: 1.25,
      recRate: 0.28,

      dmg: 1.0,
      fireRate: 6.0
    };

    let shieldEnergy = 1.0;   // 0..1
    let overheat = 0.0;       // 0..(something)
    let empAmount = 0.0;      // 0..1
    let lastImpactEnergy = 0.0;

    function resetShield() {
      shieldEnergy = 1.0;
      overheat = 0.0;
      empAmount = 0.0;
      impacts.length = 0;
      shieldUniforms.uImpactCount.value = 0;
      killAllFX();
    }

    // -----------------------------
    // Firing logic
    // -----------------------------
    function getMuzzleWorld() {
      // a point slightly in front of muzzle
      return turret.localToWorld(new THREE.Vector3(0, 0.8, 1.15));
    }

    function ensureAim() {
      if (!lastAimPoint) {
        // default aim: front-right upper of shield
        const p = shield.position.clone().add(new THREE.Vector3(0.9, 0.45, 0.9).normalize().multiplyScalar(state.radius));
        setAimAt(p);
      }
    }

    function fireOnce(customWeapon=null, customPoint=null) {
      ensureAim();
      const wName = customWeapon || state.weapon;
      const w = WEAPON[wName];

      const aimPoint = (customPoint || lastAimPoint).clone();
      updateTurretAim(aimPoint);

      const muzzleW = getMuzzleWorld();

      // Damage model varies by weapon
      const baseDmg = state.dmg;

      // Slight per-weapon scaling so they feel distinct
      const weaponMult = (
        wName === 'laser' ? 0.55 :
        wName === 'plasma' ? 0.90 :
        wName === 'kinetic' ? 1.05 :
        wName === 'railgun' ? 1.55 :
        wName === 'emp' ? 0.65 :
        0.95
      );

      const dmg = baseDmg * weaponMult;
      lastImpactEnergy = dmg;

      // Update energy + overheat
      shieldEnergy = clamp(shieldEnergy - dmg*0.035, 0.0, 1.0);
      overheat += dmg * (wName === 'laser' ? 0.12 : wName === 'emp' ? 0.22 : 0.18);
      if (wName === 'railgun') overheat += dmg * 0.25;
      if (wName === 'plasma')  overheat += dmg * 0.18;

      // EMP triggers global flicker
      if (wName === 'emp') empAmount = clamp(empAmount + 0.85, 0.0, 1.2);

      // Visuals + impact injection timing
      const doImpact = (point) => {
        // Strength for shader impacts:
        const strength = clamp(dmg * 0.55, 0.15, 1.6);

        // Slightly different impact behavior by weapon via type + strength
        addImpact(point, w.type, strength);

        // Sparks: keep tasteful
        const sparkCount = Math.floor(18 + 30 * w.spark * (0.6 + Math.random()*0.6));
        makeSparkBurst(point, 0xb6f7ff, sparkCount, 0.22 + 0.1*w.spark, 0.28 + 0.10*w.spark);

        if (wName === 'emp') {
          spawnEMP(shield.position.clone(), state.radius*1.45, 0xb6f7ff);
        }
        if (wName === 'ion') {
          spawnIonArcs(point, 0x66ffcc);
        }
      };

      // beam weapons: immediate beam + impact
      if (w.beam) {
        const beamColor =
          (wName === 'laser') ? 0x66d9ff :
          (wName === 'railgun') ? 0xb6f7ff :
          (wName === 'ion') ? 0x66ffcc : 0x66d9ff;

        const thick =
          (wName === 'railgun') ? 0.055 :
          (wName === 'ion') ? 0.045 : 0.035;

        const beam = makeBeam(muzzleW, aimPoint, beamColor, thick, 0.9);
        spawnFX(beam, (wName === 'laser' || wName === 'ion') ? 0.09 : 0.14, (o, age) => {
          o.material.opacity = (wName === 'railgun' ? 0.95 : 0.85) * (1.0 - age / (o.userData.life || 0.12));
        });
        doImpact(aimPoint);

      } else {
        // projectile travel
        const color =
          (wName === 'plasma') ? 0xff7a3c :
          (wName === 'kinetic') ? 0xffffff :
          (wName === 'emp') ? 0xb6f7ff : 0xffffff;

        const proj = makeProjectile(color, wName === 'plasma' ? 0.095 : 0.06);
        proj.position.copy(muzzleW);
        proj.userData.start = muzzleW.clone();
        proj.userData.end = aimPoint.clone();
        proj.userData.travel = w.travel;

        spawnFX(proj, Math.max(0.20, w.travel + 0.15), (o, age) => {
          const T = o.userData.travel;
          const t = T <= 0 ? 1.0 : clamp(age / T, 0.0, 1.0);
          const p = o.userData.start.clone().lerp(o.userData.end, smoothstep(0.0, 1.0, t));
          o.position.copy(p);

          // trail beam for kinetic
          if (wName === 'kinetic') {
            const trail = makeBeam(o.userData.start, p, 0xffffff, 0.015, 0.35);
            spawnFX(trail, 0.06);
          }

          if (t >= 1.0 && !o.userData.hit) {
            o.userData.hit = true;
            doImpact(o.userData.end);

            // plasma splash: extra glow at impact
            if (wName === 'plasma') {
              const splash = makeGlowSprite(new THREE.Color(0xff7a3c), 1.15);
              splash.position.copy(o.userData.end);
              splash.scale.setScalar(1.25);
              spawnFX(splash, 0.45, (sp, a)=> {
                sp.material.opacity = 0.95 * (1.0 - a/0.45);
                sp.scale.setScalar(lerp(1.2, 2.0, a/0.45));
              });
            }
          }
        });
      }
    }

    // -----------------------------
    // Test runners (burst / sustained / scenarios)
    // -----------------------------
    const runners = new Set();
    function clearRunners() {
      for (const r of runners) r.stop();
      runners.clear();
    }
    function makeRunner(stopFn) {
      const r = { stop: stopFn };
      runners.add(r);
      return r;
    }

    function burstTest() {
      clearRunners();
      ensureAim();
      const shots = 20;
      const duration = 3.0;
      const interval = duration / shots;
      let i = 0;
      const id = setInterval(() => {
        fireOnce();
        i++;
        if (i >= shots) {
          clearInterval(id);
          runners.delete(runner);
        }
      }, interval * 1000);
      const runner = makeRunner(() => clearInterval(id));
    }

    function sustainedTest() {
      clearRunners();
      ensureAim();
      const seconds = 10.0;
      const dt = 1.0 / Math.max(0.1, state.fireRate);
      let t = 0;
      const id = setInterval(() => {
        fireOnce();
        t += dt;
        if (t >= seconds) {
          clearInterval(id);
          runners.delete(runner);
        }
      }, dt * 1000);
      const runner = makeRunner(() => clearInterval(id));
    }

    function precisionScenario() {
      clearRunners();
      ensureAim();
      const seconds = 6.0;
      const dt = 1.0 / Math.max(0.1, state.fireRate);
      let t = 0;
      const aimP = lastAimPoint.clone();
      const id = setInterval(() => {
        fireOnce(null, aimP);
        t += dt;
        if (t >= seconds) {
          clearInterval(id);
          runners.delete(runner);
        }
      }, dt*1000);
      const runner = makeRunner(() => clearInterval(id));
    }

    function scatterScenario() {
      clearRunners();
      const seconds = 6.0;
      const dt = 1.0 / Math.max(0.1, state.fireRate);
      let t = 0;
      const id = setInterval(() => {
        // random point on shield (biased to forward hemisphere)
        const v = new THREE.Vector3(
          (Math.random()*2-1),
          (Math.random()*2-1)*0.6 + 0.2,
          (Math.random()*2-1)
        ).normalize();
        if (v.z < 0) v.z *= -1; // bias forward
        const p = shield.position.clone().addScaledVector(v, state.radius);
        setAimAt(p);
        fireOnce(null, p);
        t += dt;
        if (t >= seconds) {
          clearInterval(id);
          runners.delete(runner);
        }
      }, dt*1000);
      const runner = makeRunner(() => clearInterval(id));
    }

    function sweepScenario() {
      clearRunners();
      const seconds = 7.0;
      const dt = 1.0 / Math.max(0.1, state.fireRate);
      let t = 0;
      const t0 = clock.getElapsedTime();
      const id = setInterval(() => {
        const a = (clock.getElapsedTime() - t0) * 0.9;
        const v = new THREE.Vector3(
          Math.cos(a)*0.9,
          0.25 + 0.55*Math.sin(a*1.35),
          Math.sin(a)*0.9
        ).normalize();
        const p = shield.position.clone().addScaledVector(v, state.radius);
        setAimAt(p);
        fireOnce(null, p);
        t += dt;
        if (t >= seconds) {
          clearInterval(id);
          runners.delete(runner);
        }
      }, dt*1000);
      const runner = makeRunner(() => clearInterval(id));
    }

    function stressScenario() {
      clearRunners();
      const order = ['laser','plasma','kinetic','railgun','emp','ion'];
      let idx = 0;
      const seconds = 8.5;
      const dt = 0.18;
      let t = 0;
      const id = setInterval(() => {
        const w = order[idx % order.length];
        // sweep-ish aim
        const a = (clock.getElapsedTime()) * 1.2;
        const v = new THREE.Vector3(
          Math.cos(a*0.9),
          0.25 + 0.55*Math.sin(a*1.1),
          Math.sin(a*0.75)
        ).normalize();
        const p = shield.position.clone().addScaledVector(v, state.radius);
        setAimAt(p);
        fireOnce(w, p);
        idx++;
        t += dt;
        if (t >= seconds) {
          clearInterval(id);
          runners.delete(runner);
        }
      }, dt*1000);
      const runner = makeRunner(() => clearInterval(id));
    }

    let autoSweep = false;
    function toggleAutoSweep() {
      autoSweep = !autoSweep;
      document.getElementById('autoSweepBtn').textContent = autoSweep ? 'Auto Sweep (ON)' : 'Auto Impact Sweep';
    }

    // -----------------------------
    // Impact Camera (subtle zoom nudge)
    // -----------------------------
    let camKick = 0.0;
    let camKickTarget = new THREE.Vector3();
    let camBasePos = camera.position.clone();
    let camBaseTarget = controls.target.clone();

    function triggerImpactCam(worldPoint) {
      camKick = 1.0;
      camKickTarget.copy(worldPoint);
      camBasePos.copy(camera.position);
      camBaseTarget.copy(controls.target);
    }

    // -----------------------------
    // UI wiring
    // -----------------------------
    const ui = {
      shipSel: document.getElementById('shipSel'),
      presetSel: document.getElementById('presetSel'),
      weaponSel: document.getElementById('weaponSel'),
      slowSel: document.getElementById('slowSel'),
      impactCam: document.getElementById('impactCam'),
      tightBubble: document.getElementById('tightBubble'),

      baseColor: document.getElementById('baseColor'),
      rimColor: document.getElementById('rimColor'),

      opacity: document.getElementById('opacity'),
      thickness: document.getElementById('thickness'),
      fresnelPow: document.getElementById('fresnelPow'),
      fresnelInt: document.getElementById('fresnelInt'),
      noiseScale: document.getElementById('noiseScale'),
      noiseSpeed: document.getElementById('noiseSpeed'),
      noiseInt: document.getElementById('noiseInt'),
      hexDensity: document.getElementById('hexDensity'),
      radius: document.getElementById('radius'),

      rippleStr: document.getElementById('rippleStr'),
      rippleSpd: document.getElementById('rippleSpd'),
      rippleDec: document.getElementById('rippleDec'),
      overThr: document.getElementById('overThr'),
      recRate: document.getElementById('recRate'),
      dmg: document.getElementById('dmg'),
      firerate: document.getElementById('firerate'),

      fireBtn: document.getElementById('fireBtn'),
      burstBtn: document.getElementById('burstBtn'),
      sustainBtn: document.getElementById('sustainBtn'),
      resetBtn: document.getElementById('resetBtn'),

      precisionBtn: document.getElementById('precisionBtn'),
      scatterBtn: document.getElementById('scatterBtn'),
      sweepBtn: document.getElementById('sweepBtn'),
      stressBtn: document.getElementById('stressBtn'),
      autoSweepBtn: document.getElementById('autoSweepBtn'),
    };

    function bindSlider(slider, valueEl, key, fmtFn=(v)=>fmt(v,2), suffix='') {
      const update = () => {
        state[key] = parseFloat(slider.value);
        valueEl.textContent = fmtFn(state[key]) + suffix;
      };
      slider.addEventListener('input', update);
      update();
    }

    bindSlider(ui.opacity,     document.getElementById('opacityV'),     'opacity',     (v)=>fmt(v,2));
    bindSlider(ui.thickness,   document.getElementById('thicknessV'),   'thickness',   (v)=>fmt(v,2));
    bindSlider(ui.fresnelPow,  document.getElementById('fresnelPowV'),  'fresPow',     (v)=>fmt(v,2));
    bindSlider(ui.fresnelInt,  document.getElementById('fresnelIntV'),  'fresInt',     (v)=>fmt(v,2));
    bindSlider(ui.noiseScale,  document.getElementById('noiseScaleV'),  'noiseScale',  (v)=>fmt(v,2));
    bindSlider(ui.noiseSpeed,  document.getElementById('noiseSpeedV'),  'noiseSpeed',  (v)=>fmt(v,2));
    bindSlider(ui.noiseInt,    document.getElementById('noiseIntV'),    'noiseInt',    (v)=>fmt(v,2));
    bindSlider(ui.hexDensity,  document.getElementById('hexDensityV'),  'hexDensity',  (v)=>fmt(v,1));
    bindSlider(ui.radius,      document.getElementById('radiusV'),      'radius',      (v)=>fmt(v,2));

    bindSlider(ui.rippleStr,   document.getElementById('rippleStrV'),   'rippleStr',   (v)=>fmt(v,2));
    bindSlider(ui.rippleSpd,   document.getElementById('rippleSpdV'),   'rippleSpd',   (v)=>fmt(v,2));
    bindSlider(ui.rippleDec,   document.getElementById('rippleDecV'),   'rippleDec',   (v)=>fmt(v,2));

    bindSlider(ui.overThr,     document.getElementById('overThrV'),     'overThr',     (v)=>fmt(v,2));
    bindSlider(ui.recRate,     document.getElementById('recRateV'),     'recRate',     (v)=>fmt(v,2));
    bindSlider(ui.dmg,         document.getElementById('dmgV'),         'dmg',         (v)=>fmt(v,2));
    bindSlider(ui.firerate,    document.getElementById('firerateV'),    'fireRate',    (v)=>fmt(v,1), '/s');

    ui.baseColor.addEventListener('input', () => state.baseColor = ui.baseColor.value);
    ui.rimColor.addEventListener('input', () => state.rimColor = ui.rimColor.value);

    ui.shipSel.addEventListener('change', () => {
      state.ship = ui.shipSel.value;
      setShip(state.ship);
    });

    ui.presetSel.addEventListener('change', () => {
      state.preset = parseInt(ui.presetSel.value, 10);
      shieldUniforms.uPreset.value = state.preset;
    });

    ui.weaponSel.addEventListener('change', () => state.weapon = ui.weaponSel.value);
    ui.slowSel.addEventListener('change', () => state.slow = parseFloat(ui.slowSel.value));
    ui.impactCam.addEventListener('change', () => state.impactCam = ui.impactCam.checked);
    ui.tightBubble.addEventListener('change', () => state.tightBubble = ui.tightBubble.checked);

    ui.fireBtn.addEventListener('click', () => { clearRunners(); fireOnce(); });
    ui.burstBtn.addEventListener('click', burstTest);
    ui.sustainBtn.addEventListener('click', sustainedTest);
    ui.resetBtn.addEventListener('click', () => { clearRunners(); resetShield(); });

    ui.precisionBtn.addEventListener('click', precisionScenario);
    ui.scatterBtn.addEventListener('click', scatterScenario);
    ui.sweepBtn.addEventListener('click', sweepScenario);
    ui.stressBtn.addEventListener('click', stressScenario);
    ui.autoSweepBtn.addEventListener('click', toggleAutoSweep);

    // -----------------------------
    // Keyboard shortcuts
    // -----------------------------
    window.addEventListener('keydown', (e) => {
      if (e.repeat) return;
      if (e.code === 'Space') { e.preventDefault(); clearRunners(); fireOnce(); }
      if (e.key.toLowerCase() === 'r') { clearRunners(); resetShield(); }
      if (e.key.toLowerCase() === 'c') { state.impactCam = !state.impactCam; ui.impactCam.checked = state.impactCam; }
      if (e.key.toLowerCase() === 'o') { toggleAutoSweep(); }
      if (e.key >= '1' && e.key <= '6') {
        const order = ['laser','plasma','kinetic','railgun','emp','ion'];
        state.weapon = order[parseInt(e.key,10)-1];
        ui.weaponSel.value = state.weapon;
      }
    });

    // -----------------------------
    // Animation loop
    // -----------------------------
    const clock = new THREE.Clock();
    let flashKick = 0.0;

    // FPS counter
    let fpsAcc = 0, fpsFrames = 0, fpsLast = 0;
    const fpsEl = document.getElementById('fps');
    const energyEl = document.getElementById('energy');
    const overloadEl = document.getElementById('overload');
    const overPill = document.getElementById('overPill');
    const energyPill = document.getElementById('energyPill');

    function syncUniforms(t) {
      shieldUniforms.uTime.value = t;
      shieldUniforms.uBaseColor.value.copy(hexToColor(state.baseColor));
      shieldUniforms.uRimColor.value.copy(hexToColor(state.rimColor));
      shieldUniforms.uOpacity.value = state.opacity;
      shieldUniforms.uThickness.value = state.thickness;
      shieldUniforms.uFresnelPower.value = state.fresPow;
      shieldUniforms.uFresnelIntensity.value = state.fresInt;
      shieldUniforms.uNoiseScale.value = state.noiseScale;
      shieldUniforms.uNoiseSpeed.value = state.noiseSpeed;
      shieldUniforms.uNoiseIntensity.value = state.noiseInt;
      shieldUniforms.uHexDensity.value = state.hexDensity;
      shieldUniforms.uRippleStrength.value = state.rippleStr;
      shieldUniforms.uRippleSpeed.value = state.rippleSpd;
      shieldUniforms.uRippleDecay.value = state.rippleDec;

      // overload/energy/emp
      shieldUniforms.uEnergy.value = shieldEnergy;
      shieldUniforms.uOverload.value = clamp((overheat - state.overThr) / 1.0, 0.0, 1.0);
      shieldUniforms.uEmp.value = clamp(empAmount, 0.0, 1.0);

      // shield radius update
      shield.scale.setScalar(state.radius / 1.75);
      shieldGlow.scale.setScalar((state.radius * 1.018) / 1.78);

      // tight bubble "conformal" hack (hug ship more + slight ship tint)
      if (state.tightBubble) {
        shield.scale.setScalar((state.radius * 0.93) / 1.75);
        shieldGlow.scale.setScalar((state.radius * 0.96) / 1.78);
        // nudge opacity a bit up for readability when tight
        shieldUniforms.uOpacity.value = clamp(state.opacity + 0.03, 0.02, 0.9);
      }

      // outer glow color follows rim
      glowMat.color.copy(hexToColor(state.rimColor)).multiplyScalar(0.9);
      glowMat.opacity = 0.028 + 0.028 * state.fresInt + 0.04 * clamp((1.0 - shieldEnergy), 0, 1);
    }

    function updateFX(dt) {
      const now = clock.getElapsedTime();
      for (let i = activeFX.length - 1; i >= 0; i--) {
        const f = activeFX[i];
        const age = now - f.t0;
        if (f.updateFn) f.updateFn(f.obj, age, dt);
        if (age >= f.life) {
          fx.remove(f.obj);
          activeFX.splice(i, 1);
        }
      }
    }

    function animatePracticals(t) {
      // subtle breathing
      practicals.forEach((p, i) => {
        const breathe = 0.85 + 0.15*Math.sin(t*0.9 + p.phase + i*0.7);
        const flash = 1.0 + 0.6*flashKick;
        p.light.intensity = p.base * breathe * flash;
      });
    }

    function updateEnergy(dt) {
      // recover energy
      shieldEnergy = clamp(shieldEnergy + state.recRate * dt * 0.08, 0.0, 1.0);

      // cool overheat
      const cool = (0.45 + 0.55*shieldEnergy) * state.recRate;
      overheat = Math.max(0.0, overheat - cool * dt * 0.55);

      // emp decay
      empAmount = Math.max(0.0, empAmount - dt * 0.85);

      // if overloaded, energy is unstable (a little extra flicker)
      const overload = clamp((overheat - state.overThr)/1.0, 0.0, 1.0);
      if (overload > 0.0) {
        shieldEnergy = clamp(shieldEnergy - overload * dt * 0.04, 0.0, 1.0);
      }
    }

    function updateHUD() {
      const pct = Math.round(shieldEnergy * 100);
      energyEl.textContent = pct;

      const overloaded = (overheat > state.overThr + 0.02);
      overloadEl.textContent = overloaded ? 'YES' : 'NO';
      overPill.classList.toggle('warn', overloaded);
      overPill.classList.toggle('ok', !overloaded);
      energyPill.classList.toggle('warn', pct < 25);
      energyPill.classList.toggle('ok', pct >= 25);

      // (Optional) you could show lastImpactEnergy somewhere; kept minimal in UI.
    }

    function updateImpactCam(dt) {
      if (camKick <= 0.0) return;
      camKick = Math.max(0.0, camKick - dt * 2.8);
      const k = smoothstep(0.0, 1.0, camKick);

      // bring camera slightly closer and bias target toward impact
      const toCam = camBasePos.clone().sub(camBaseTarget);
      const dist = toCam.length();
      const dir = toCam.normalize();

      const desiredDist = lerp(dist, Math.max(2.4, dist * 0.72), k);
      const desiredTarget = camBaseTarget.clone().lerp(camKickTarget, 0.22*k);

      controls.target.copy(desiredTarget);
      camera.position.copy(desiredTarget.clone().addScaledVector(dir, desiredDist));
      camera.lookAt(controls.target);
    }

    function updateAutoSweep(t, dt) {
      if (!autoSweep) return;
      // Lissajous-like sweep around shield
      const a = t * 0.9;
      const v = new THREE.Vector3(
        Math.cos(a*1.05) * 0.9,
        0.20 + 0.55*Math.sin(a*1.33),
        Math.sin(a*0.78) * 0.9
      ).normalize();

      const p = shield.position.clone().addScaledVector(v, state.radius);
      setAimAt(p);

      // fire at a steady cadence
      autoFireAcc += dt;
      const step = 1.0 / Math.max(0.1, state.fireRate);
      if (autoFireAcc >= step) {
        autoFireAcc = 0.0;
        fireOnce(null, p);
      }
    }

    let autoFireAcc = 0.0;

    // -----------------------------
    // Resize
    // -----------------------------
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Initialize a default aim
    ensureAim();

    // -----------------------------
    // Main loop
    // -----------------------------
    function tick() {
      const rawDt = clock.getDelta();
      const dt = rawDt * state.slow;
      const t = clock.getElapsedTime();

      // Animate ship a touch (subtle “alive”)
      if (currentShip) {
        currentShip.rotation.y += dt * 0.12;
        const bob = 0.05 * Math.sin(t*1.2);
        shipRoot.position.y = 1.05 + bob;
        shield.position.copy(shipRoot.position);
        shieldGlow.position.copy(shipRoot.position);
      }

      // Turret aim at last aim point
      if (lastAimPoint) updateTurretAim(lastAimPoint);

      // Flash kick decays
      flashKick = Math.max(0.0, flashKick - dt * 5.0);

      // Systems update
      updateEnergy(dt);
      updateFX(dt);
      animatePracticals(t);
      updateAutoSweep(t, dt);

      // UI + shader uniforms
      syncUniforms(t);
      updateHUD();

      // Impact cam
      if (state.impactCam) updateImpactCam(dt);

      // Orbit controls
      controls.update();

      // Render
      renderer.render(scene, camera);

      // FPS calc
      fpsAcc += rawDt;
      fpsFrames++;
      if (fpsAcc >= 0.5) {
        const fps = Math.round(fpsFrames / fpsAcc);
        fpsEl.textContent = fps;
        fpsAcc = 0; fpsFrames = 0;
      }

      requestAnimationFrame(tick);
    }
    tick();

  })();
  </script>
</body>
</html>
